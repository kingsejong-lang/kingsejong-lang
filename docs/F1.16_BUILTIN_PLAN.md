# F1.16: ë‚´ì¥ í•¨ìˆ˜ ì‹œìŠ¤í…œ êµ¬í˜„ ê³„íš

> **ìƒíƒœ**: ğŸ“ ê³„íš
> **ìš°ì„ ìˆœìœ„**: CRITICAL
> **ì˜ˆìƒ ì†Œìš”**: 1-2ì¼
> **ë¸Œëœì¹˜**: `feature/f1.16-builtin-functions`

---

## ê°œìš”

KingSejong ì–¸ì–´ì˜ ê¸°ë³¸ ë‚´ì¥ í•¨ìˆ˜ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì¶œë ¥, ì…ë ¥, íƒ€ì… ì²´í¬ ë“± ê¸°ë³¸ì ì¸ í”„ë¡œê·¸ë˜ë°ì— í•„ìš”í•œ í•¨ìˆ˜ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤.

---

## ëª©í‘œ

1. âœ… ë‚´ì¥ í•¨ìˆ˜ ë“±ë¡ ì‹œìŠ¤í…œ êµ¬ì¶•
2. âœ… ì¶œë ¥() í•¨ìˆ˜ êµ¬í˜„
3. âœ… íƒ€ì…() í•¨ìˆ˜ êµ¬í˜„
4. âœ… ê¸¸ì´() í•¨ìˆ˜ êµ¬í˜„
5. â¸ï¸ ì…ë ¥() í•¨ìˆ˜ êµ¬í˜„ (ì„ íƒì )

---

## ê¸°ìˆ  ì„¤ê³„

### 1. ë‚´ì¥ í•¨ìˆ˜ Value íƒ€ì… ì¶”ê°€

**íŒŒì¼**: `src/evaluator/Value.h`

```cpp
enum class ValueType {
    NULL_TYPE,
    INTEGER,
    FLOAT,
    STRING,
    BOOLEAN,
    FUNCTION,
    BUILTIN_FUNCTION,  // ì¶”ê°€!
    ARRAY
};

// Value í´ë˜ìŠ¤ì— ì¶”ê°€
class Value {
    // ...
    using BuiltinFn = std::function<Value(const std::vector<Value>&)>;

    Value(BuiltinFn fn);
    bool isBuiltinFunction() const;
    BuiltinFn asBuiltinFunction() const;
};
```

### 2. ë‚´ì¥ í•¨ìˆ˜ ë“±ë¡ ì‹œìŠ¤í…œ

**íŒŒì¼**: `src/evaluator/Builtin.h` (ì‹ ê·œ)

```cpp
#pragma once

#include "Value.h"
#include <string>
#include <unordered_map>
#include <functional>

namespace kingsejong {
namespace evaluator {

/**
 * @class Builtin
 * @brief ë‚´ì¥ í•¨ìˆ˜ ê´€ë¦¬ ì‹œìŠ¤í…œ
 */
class Builtin {
public:
    using BuiltinFn = std::function<Value(const std::vector<Value>&)>;

    /**
     * @brief ë‚´ì¥ í•¨ìˆ˜ ë“±ë¡
     */
    static void registerBuiltin(const std::string& name, BuiltinFn fn);

    /**
     * @brief ë‚´ì¥ í•¨ìˆ˜ ì¡°íšŒ
     */
    static Value getBuiltin(const std::string& name);

    /**
     * @brief ë‚´ì¥ í•¨ìˆ˜ ì¡´ì¬ í™•ì¸
     */
    static bool hasBuiltin(const std::string& name);

    /**
     * @brief ëª¨ë“  ë‚´ì¥ í•¨ìˆ˜ ë“±ë¡ (ì´ˆê¸°í™”)
     */
    static void registerAllBuiltins();

private:
    static std::unordered_map<std::string, Value> builtins_;
};

} // namespace evaluator
} // namespace kingsejong
```

**íŒŒì¼**: `src/evaluator/Builtin.cpp` (ì‹ ê·œ)

```cpp
#include "Builtin.h"
#include <iostream>

namespace kingsejong {
namespace evaluator {

std::unordered_map<std::string, Value> Builtin::builtins_;

void Builtin::registerBuiltin(const std::string& name, BuiltinFn fn) {
    builtins_[name] = Value(fn);
}

Value Builtin::getBuiltin(const std::string& name) {
    auto it = builtins_.find(name);
    if (it != builtins_.end()) {
        return it->second;
    }
    return Value(); // null
}

bool Builtin::hasBuiltin(const std::string& name) {
    return builtins_.find(name) != builtins_.end();
}

// ë‚´ì¥ í•¨ìˆ˜ êµ¬í˜„ë“¤

/**
 * ì¶œë ¥(ê°’1, ê°’2, ...) - ì½˜ì†”ì— ì¶œë ¥
 */
static Value builtin_ì¶œë ¥(const std::vector<Value>& args) {
    for (size_t i = 0; i < args.size(); ++i) {
        if (i > 0) std::cout << " ";

        if (args[i].isString()) {
            std::cout << args[i].asString();
        } else if (args[i].isInteger()) {
            std::cout << args[i].asInteger();
        } else if (args[i].isFloat()) {
            std::cout << args[i].asFloat();
        } else if (args[i].isBoolean()) {
            std::cout << (args[i].asBoolean() ? "ì°¸" : "ê±°ì§“");
        } else if (args[i].isNull()) {
            std::cout << "null";
        } else if (args[i].isFunction()) {
            std::cout << "[í•¨ìˆ˜]";
        } else if (args[i].isBuiltinFunction()) {
            std::cout << "[ë‚´ì¥í•¨ìˆ˜]";
        } else if (args[i].isArray()) {
            std::cout << "[ë°°ì—´]";
        }
    }
    std::cout << std::endl;
    return Value(); // null
}

/**
 * íƒ€ì…(ê°’) - ê°’ì˜ íƒ€ì…ì„ ë¬¸ìì—´ë¡œ ë°˜í™˜
 */
static Value builtin_íƒ€ì…(const std::vector<Value>& args) {
    if (args.size() != 1) {
        throw std::runtime_error("íƒ€ì…() í•¨ìˆ˜ëŠ” ì •í™•íˆ 1ê°œì˜ ì¸ìê°€ í•„ìš”í•©ë‹ˆë‹¤");
    }

    const Value& arg = args[0];
    if (arg.isInteger()) return Value("ì •ìˆ˜");
    if (arg.isFloat()) return Value("ì‹¤ìˆ˜");
    if (arg.isString()) return Value("ë¬¸ìì—´");
    if (arg.isBoolean()) return Value("ë…¼ë¦¬");
    if (arg.isNull()) return Value("null");
    if (arg.isFunction()) return Value("í•¨ìˆ˜");
    if (arg.isBuiltinFunction()) return Value("ë‚´ì¥í•¨ìˆ˜");
    if (arg.isArray()) return Value("ë°°ì—´");

    return Value("ì•Œ ìˆ˜ ì—†ìŒ");
}

/**
 * ê¸¸ì´(ë°°ì—´/ë¬¸ìì—´) - ê¸¸ì´ ë°˜í™˜
 */
static Value builtin_ê¸¸ì´(const std::vector<Value>& args) {
    if (args.size() != 1) {
        throw std::runtime_error("ê¸¸ì´() í•¨ìˆ˜ëŠ” ì •í™•íˆ 1ê°œì˜ ì¸ìê°€ í•„ìš”í•©ë‹ˆë‹¤");
    }

    const Value& arg = args[0];
    if (arg.isString()) {
        // UTF-8 ë¬¸ì ìˆ˜ ê³„ì‚°
        const std::string& str = arg.asString();
        int64_t count = 0;
        for (size_t i = 0; i < str.length(); ) {
            unsigned char c = static_cast<unsigned char>(str[i]);
            if ((c & 0x80) == 0) {
                i += 1; // ASCII
            } else if ((c & 0xE0) == 0xC0) {
                i += 2; // 2-byte UTF-8
            } else if ((c & 0xF0) == 0xE0) {
                i += 3; // 3-byte UTF-8 (í•œê¸€)
            } else if ((c & 0xF8) == 0xF0) {
                i += 4; // 4-byte UTF-8
            } else {
                i += 1; // fallback
            }
            count++;
        }
        return Value(count);
    }

    if (arg.isArray()) {
        return Value(static_cast<int64_t>(arg.asArray().size()));
    }

    throw std::runtime_error("ê¸¸ì´() í•¨ìˆ˜ëŠ” ë¬¸ìì—´ ë˜ëŠ” ë°°ì—´ íƒ€ì…ì´ì–´ì•¼ í•©ë‹ˆë‹¤");
}

void Builtin::registerAllBuiltins() {
    registerBuiltin("ì¶œë ¥", builtin_ì¶œë ¥);
    registerBuiltin("íƒ€ì…", builtin_íƒ€ì…);
    registerBuiltin("ê¸¸ì´", builtin_ê¸¸ì´);
}

} // namespace evaluator
} // namespace kingsejong
```

### 3. Evaluator í†µí•©

**íŒŒì¼**: `src/evaluator/Evaluator.cpp`

evalIdentifier()ì—ì„œ ë‚´ì¥ í•¨ìˆ˜ ì²´í¬ ì¶”ê°€:

```cpp
Value Evaluator::evalIdentifier(ast::Identifier* ident) {
    const std::string& name = ident->name();

    // 1. ë¨¼ì € í™˜ê²½ì—ì„œ ë³€ìˆ˜ ì¡°íšŒ
    Value* val = env_->get(name);
    if (val) {
        return *val;
    }

    // 2. ë‚´ì¥ í•¨ìˆ˜ ì¡°íšŒ
    if (Builtin::hasBuiltin(name)) {
        return Builtin::getBuiltin(name);
    }

    // 3. ì •ì˜ë˜ì§€ ì•ŠìŒ
    throw std::runtime_error("ì •ì˜ë˜ì§€ ì•Šì€ ì‹ë³„ì: " + name);
}
```

evalCallExpression()ì—ì„œ ë‚´ì¥ í•¨ìˆ˜ í˜¸ì¶œ ì²˜ë¦¬:

```cpp
Value Evaluator::evalCallExpression(ast::CallExpression* expr) {
    Value function = eval(const_cast<ast::Expression*>(expr->function()));

    // ì¸ì í‰ê°€
    std::vector<Value> args;
    for (const auto& arg : expr->arguments()) {
        args.push_back(eval(const_cast<ast::Expression*>(arg.get())));
    }

    // ë‚´ì¥ í•¨ìˆ˜ í˜¸ì¶œ
    if (function.isBuiltinFunction()) {
        auto fn = function.asBuiltinFunction();
        return fn(args);
    }

    // ì‚¬ìš©ì ì •ì˜ í•¨ìˆ˜ í˜¸ì¶œ
    if (function.isFunction()) {
        // ... ê¸°ì¡´ ë¡œì§
    }

    throw std::runtime_error("í•¨ìˆ˜ê°€ ì•„ë‹™ë‹ˆë‹¤");
}
```

### 4. main.cpp ì´ˆê¸°í™”

```cpp
int main() {
    using namespace kingsejong::evaluator;

    // ë‚´ì¥ í•¨ìˆ˜ ë“±ë¡
    Builtin::registerAllBuiltins();

    // ...
}
```

---

## êµ¬í˜„ ìˆœì„œ

### Step 1: Value íƒ€ì… í™•ì¥
1. `src/evaluator/Value.h`ì— BUILTIN_FUNCTION íƒ€ì… ì¶”ê°€
2. BuiltinFn íƒ€ì… ì •ì˜
3. isBuiltinFunction(), asBuiltinFunction() ë©”ì„œë“œ ì¶”ê°€
4. Value::toString() ì—…ë°ì´íŠ¸

### Step 2: Builtin ì‹œìŠ¤í…œ
1. `src/evaluator/Builtin.h` ì‘ì„±
2. `src/evaluator/Builtin.cpp` ì‘ì„±
3. CMakeLists.txt ì—…ë°ì´íŠ¸

### Step 3: ë‚´ì¥ í•¨ìˆ˜ êµ¬í˜„
1. builtin_ì¶œë ¥() êµ¬í˜„
2. builtin_íƒ€ì…() êµ¬í˜„
3. builtin_ê¸¸ì´() êµ¬í˜„
4. registerAllBuiltins() êµ¬í˜„

### Step 4: Evaluator í†µí•©
1. evalIdentifier()ì—ì„œ ë‚´ì¥ í•¨ìˆ˜ ì¡°íšŒ
2. evalCallExpression()ì—ì„œ ë‚´ì¥ í•¨ìˆ˜ í˜¸ì¶œ ì²˜ë¦¬

### Step 5: í…ŒìŠ¤íŠ¸
1. `tests/BuiltinTest.cpp` ì‘ì„±
   - ì¶œë ¥() í…ŒìŠ¤íŠ¸ (5ê°œ)
   - íƒ€ì…() í…ŒìŠ¤íŠ¸ (7ê°œ)
   - ê¸¸ì´() í…ŒìŠ¤íŠ¸ (3ê°œ)

---

## í…ŒìŠ¤íŠ¸ ê³„íš

### tests/BuiltinTest.cpp

```cpp
TEST(BuiltinTest, ShouldPrintInteger) {
    std::stringstream buffer;
    std::streambuf* old = std::cout.rdbuf(buffer.rdbuf());

    evalInput("ì¶œë ¥(42)");

    EXPECT_EQ(buffer.str(), "42\n");
    std::cout.rdbuf(old);
}

TEST(BuiltinTest, ShouldPrintMultipleValues) {
    // ì¶œë ¥(1, 2, 3) â†’ "1 2 3\n"
}

TEST(BuiltinTest, ShouldPrintKoreanString) {
    // ì¶œë ¥("ì•ˆë…•í•˜ì„¸ìš”") â†’ "ì•ˆë…•í•˜ì„¸ìš”\n"
}

TEST(BuiltinTest, ShouldReturnTypeInteger) {
    auto result = evalInput("íƒ€ì…(42)");
    EXPECT_EQ(result.asString(), "ì •ìˆ˜");
}

TEST(BuiltinTest, ShouldReturnTypeString) {
    auto result = evalInput("íƒ€ì…(\"ì•ˆë…•\")");
    EXPECT_EQ(result.asString(), "ë¬¸ìì—´");
}

TEST(BuiltinTest, ShouldReturnTypeFunction) {
    auto result = evalInput("íƒ€ì…(í•¨ìˆ˜(x) { x })");
    EXPECT_EQ(result.asString(), "í•¨ìˆ˜");
}

TEST(BuiltinTest, ShouldReturnStringLength) {
    auto result = evalInput("ê¸¸ì´(\"ì•ˆë…•í•˜ì„¸ìš”\")");
    EXPECT_EQ(result.asInteger(), 5);  // 5ê¸€ì
}

TEST(BuiltinTest, ShouldReturnArrayLength) {
    auto result = evalInput("ê¸¸ì´([1, 2, 3, 4, 5])");
    EXPECT_EQ(result.asInteger(), 5);
}

TEST(BuiltinTest, ShouldThrowOnInvalidLengthArgument) {
    EXPECT_THROW(evalInput("ê¸¸ì´(42)"), std::runtime_error);
}
```

---

## ì™„ë£Œ ì¡°ê±´

- [x] Value íƒ€ì…ì— BUILTIN_FUNCTION ì¶”ê°€
- [x] Builtin.h/cpp êµ¬í˜„
- [x] ì¶œë ¥() í•¨ìˆ˜ ë™ì‘
- [x] íƒ€ì…() í•¨ìˆ˜ ë™ì‘
- [x] ê¸¸ì´() í•¨ìˆ˜ ë™ì‘
- [x] UTF-8 í•œê¸€ ë¬¸ì ìˆ˜ ì •í™•íˆ ê³„ì‚°
- [x] í…ŒìŠ¤íŠ¸ 15ê°œ ì´ìƒ ì‘ì„±
- [x] ëª¨ë“  í…ŒìŠ¤íŠ¸ í†µê³¼
- [x] ë¬¸ì„œ ì—…ë°ì´íŠ¸

---

## ì˜ˆì œ ì½”ë“œ

ì™„ë£Œ í›„ ì‹¤í–‰ ê°€ëŠ¥í•œ ì˜ˆì œ:

```sejong
# ê¸°ë³¸ ì¶œë ¥
ì¶œë ¥("ì•ˆë…•í•˜ì„¸ìš”!")
ì¶œë ¥(42)
ì¶œë ¥(3.14)
ì¶œë ¥(ì°¸)

# ì—¬ëŸ¬ ê°’ ì¶œë ¥
ì¶œë ¥("ë‚˜ì´:", 25, "ì„¸")

# íƒ€ì… í™•ì¸
ì •ìˆ˜ x = 100
ì¶œë ¥(íƒ€ì…(x))  # "ì •ìˆ˜"

ë¬¸ìì—´ ì´ë¦„ = "ê¹€ì² ìˆ˜"
ì¶œë ¥(íƒ€ì…(ì´ë¦„))  # "ë¬¸ìì—´"

# ê¸¸ì´ í™•ì¸
ì¶œë ¥(ê¸¸ì´("ì•ˆë…•í•˜ì„¸ìš”"))  # 5
ì¶œë ¥(ê¸¸ì´([1, 2, 3]))    # 3

# í•¨ìˆ˜ì™€ í•¨ê»˜ ì‚¬ìš©
í•¨ìˆ˜ ì¸ì‚¬(ì´ë¦„) {
    ì¶œë ¥("ì•ˆë…•í•˜ì„¸ìš”,", ì´ë¦„, "ë‹˜!")
}

ì¸ì‚¬("ì² ìˆ˜")  # "ì•ˆë…•í•˜ì„¸ìš”, ì² ìˆ˜ ë‹˜!"
```

---

## ì°¸ê³ ì‚¬í•­

- ì¶œë ¥() í•¨ìˆ˜ëŠ” ìë™ìœ¼ë¡œ ê°œí–‰(\n)ì„ ì¶”ê°€
- ì—¬ëŸ¬ ì¸ìëŠ” ê³µë°±ìœ¼ë¡œ êµ¬ë¶„
- UTF-8 í•œê¸€ ë¬¸ìëŠ” 3ë°”ì´íŠ¸ì´ë¯€ë¡œ ê¸¸ì´() ê³„ì‚° ì‹œ ì£¼ì˜
- ë‚´ì¥ í•¨ìˆ˜ëŠ” ì „ì—­ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì— ìë™ ë“±ë¡
- ì‚¬ìš©ìê°€ ê°™ì€ ì´ë¦„ì˜ ë³€ìˆ˜ë¥¼ ì •ì˜í•˜ë©´ ë³€ìˆ˜ê°€ ìš°ì„  (shadowing)

---

## í–¥í›„ í™•ì¥

Phase 2ì—ì„œ ì¶”ê°€í•  ë‚´ì¥ í•¨ìˆ˜ë“¤:

- ì…ë ¥(prompt) - ì‚¬ìš©ì ì…ë ¥
- ì •ìˆ˜ë¡œ(ê°’) - ì •ìˆ˜ ë³€í™˜
- ì‹¤ìˆ˜ë¡œ(ê°’) - ì‹¤ìˆ˜ ë³€í™˜
- ë¬¸ìì—´ë¡œ(ê°’) - ë¬¸ìì—´ ë³€í™˜
- ì ˆëŒ€ê°’(x) - ì ˆëŒ“ê°’
- ìµœëŒ€ê°’(...) - ìµœëŒ“ê°’
- ìµœì†Œê°’(...) - ìµœì†Ÿê°’
- ë²”ìœ„(ì‹œì‘, ë) - ë²”ìœ„ ìƒì„±
