# =============================================================================
# KingSejong Hot Path Detection (핫 패스 감지) 예제
# =============================================================================
# 파일: examples/hot_path_detection.ksj
# 설명: JIT 컴파일을 위한 핫 패스 감지 시스템 시연
#       자주 실행되는 함수와 루프를 식별하여 최적화 대상을 결정

출력("===== KingSejong Hot Path Detection 시스템 =====")
출력()

# -----------------------------------------------------------------------------
# 예제 1: 자주 호출되는 함수 (Hot Function)
# -----------------------------------------------------------------------------
출력("📌 예제 1: 자주 호출되는 함수")
출력()

함수 피보나치(n) {
    만약 (n <= 1) {
        반환 n
    }
    반환 피보나치(n - 1) + 피보나치(n - 2)
}

출력("피보나치(10) 계산 중...")
정수 결과1 = 피보나치(10)
출력("  결과:", 결과1)
출력("  → '피보나치' 함수는 재귀 호출로 인해 매우 자주 실행됩니다")
출력("  → JIT 컴파일러는 이 함수를 '핫 함수'로 식별할 것입니다")
출력()

# -----------------------------------------------------------------------------
# 예제 2: 반복되는 루프 (Hot Loop)
# -----------------------------------------------------------------------------
출력("📌 예제 2: 핫 루프 감지")
출력()

함수 배열합계(배열 arr) {
    정수 합 = 0
    정수 크기 = 배열크기(arr)
    i가 0부터 크기미만 반복한다 {
        합 = 합 + arr[i]
    }
    반환 합
}

배열 숫자들 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

출력("배열 합계를 여러 번 계산:")
j가 1부터 5까지 반복한다 {
    정수 합 = 배열합계(숫자들)
    출력("  반복", j, "- 합계:", 합)
}

출력()
출력("  → 배열합계 함수 내부의 루프가 여러 번 실행됩니다")
출력("  → 이 루프는 '핫 루프'로 감지되어 최적화 대상이 됩니다")
출력()

# -----------------------------------------------------------------------------
# 예제 3: 중첩 루프 (Nested Hot Loops)
# -----------------------------------------------------------------------------
출력("📌 예제 3: 중첩된 핫 루프")
출력()

함수 행렬곱셈(배열 a, 배열 b, 정수 크기) {
    배열 결과 = []

    외부가 0부터 크기미만 반복한다 {
        정수 합 = 0
        내부가 0부터 크기미만 반복한다 {
            합 = 합 + a[외부] * b[내부]
        }
        배열추가(결과, 합)
    }

    반환 결과
}

배열 벡터1 = [1, 2, 3]
배열 벡터2 = [4, 5, 6]

출력("3x3 행렬 연산 수행:")
배열 결과3 = 행렬곱셈(벡터1, 벡터2, 3)
출력("  결과:", 결과3)
출력()
출력("  → 외부 루프: 3회 실행")
출력("  → 내부 루프: 9회 실행 (3 x 3)")
출력("  → 내부 루프가 더 '핫'하므로 우선 최적화 대상")
출력()

# -----------------------------------------------------------------------------
# 예제 4: 반복 호출되는 함수 (Function Call Frequency)
# -----------------------------------------------------------------------------
출력("📌 예제 4: 함수 호출 빈도 추적")
출력()

함수 제곱(n) {
    반환 n * n
}

함수 거듭제곱(밑, 지수) {
    정수 결과 = 1
    i가 1부터 지수까지 반복한다 {
        결과 = 결과 * 밑
    }
    반환 결과
}

출력("여러 수학 연산 수행:")

# 제곱 함수를 20번 호출
i가 1부터 20까지 반복한다 {
    정수 n = 제곱(i)
}

출력("  제곱 함수: 20회 호출")

# 거듭제곱 함수를 5번만 호출
j가 1부터 5까지 반복한다 {
    정수 m = 거듭제곱(2, j)
}

출력("  거듭제곱 함수: 5회 호출")
출력()
출력("  → '제곱' 함수가 더 자주 호출되어 더 높은 최적화 우선순위를 가집니다")
출력("  → JIT 컴파일러는 호출 빈도를 기반으로 컴파일 순서를 결정합니다")
출력()

# -----------------------------------------------------------------------------
# 예제 5: 실행 시간 기반 우선순위 (Execution Time Profiling)
# -----------------------------------------------------------------------------
출력("📌 예제 5: 실행 시간 프로파일링")
출력()

함수 빠른연산(n) {
    반환 n + 1
}

함수 느린연산(n) {
    정수 결과 = 0
    i가 1부터 1000까지 반복한다 {
        결과 = 결과 + n
    }
    반환 결과
}

출력("빠른 연산 vs 느린 연산:")

# 빠른 연산을 많이 호출
k가 1부터 10까지 반복한다 {
    정수 x = 빠른연산(k)
}

# 느린 연산을 적게 호출
정수 y = 느린연산(5)

출력()
출력("  → 빠른연산: 10회 호출, 낮은 실행 시간")
출력("  → 느린연산: 1회 호출, 높은 실행 시간")
출력("  → Hot Path Detector는 호출 횟수와 실행 시간을 모두 고려합니다")
출력("  → 총 실행 시간이 큰 함수가 최적화 우선순위를 가집니다")
출력()

# -----------------------------------------------------------------------------
# Hot Path Detection 임계값
# -----------------------------------------------------------------------------
출력("===== Hot Path Detection 임계값 =====")
출력()
출력("기본 설정:")
출력("  • 함수 호출 임계값: 1,000회")
출력("  • 루프 백엣지 임계값: 10,000회")
출력("  • Very Hot 임계값: 기본 임계값의 10배")
출력()
출력("JIT 컴파일 전략:")
출력("  1. Hot 감지: 임계값 도달 시 JIT Tier 1 (템플릿 JIT) 컴파일")
출력("  2. Very Hot 감지: Tier 2 (LLVM 최적화 JIT)로 재컴파일")
출력("  3. 우선순위: 실행 횟수 × 평균 실행 시간이 높은 순")
출력()

출력("===== Hot Path Detection 완료 =====")
출력()
출력("💡 핵심 요약:")
출력("  - 자주 실행되는 함수와 루프를 자동으로 감지")
출력("  - 호출 빈도와 실행 시간을 모두 추적")
출력("  - JIT 컴파일 우선순위를 결정하는 데이터 제공")
출력("  - 성능 병목 지점 식별 및 최적화 가능")
