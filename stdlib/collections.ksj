# collections 모듈
# KingSejong 표준 라이브러리 - 자료구조 (Set, Map, Queue, Stack, Deque)

# ============================================================================
# Set (집합) - 중복 없는 요소 집합
# ============================================================================

# 빈 Set을 생성한다
Set_생성 = 함수() {
    반환 []
}

# Set에 값을 추가한다 (중복 무시)
Set_추가 = 함수(집합, 값) {
    # 이미 존재하는지 확인
    i가 0부터 길이(집합) 미만 {
        만약 (집합[i] == 값) {
            반환 집합  # 중복이면 그대로 반환
        }
    }

    반환 집합 + [값]
}

# Set에서 값을 제거한다
Set_제거 = 함수(집합, 값) {
    결과 = []

    i가 0부터 길이(집합) 미만 {
        만약 (집합[i] != 값) {
            결과 = 결과 + [집합[i]]
        }
    }

    반환 결과
}

# Set에 값이 포함되어 있는지 확인
Set_포함 = 함수(집합, 값) {
    i가 0부터 길이(집합) 미만 {
        만약 (집합[i] == 값) {
            반환 참
        }
    }

    반환 거짓
}

# Set의 크기를 반환
Set_크기 = 함수(집합) {
    반환 길이(집합)
}

# Set이 비어있는지 확인
Set_비어있는가 = 함수(집합) {
    반환 길이(집합) == 0
}

# 두 Set의 합집합 (A ∪ B)
Set_합집합 = 함수(집합1, 집합2) {
    결과 = 집합1

    i가 0부터 길이(집합2) 미만 {
        결과 = Set_추가(결과, 집합2[i])
    }

    반환 결과
}

# 두 Set의 교집합 (A ∩ B)
Set_교집합 = 함수(집합1, 집합2) {
    결과 = []

    i가 0부터 길이(집합1) 미만 {
        만약 (Set_포함(집합2, 집합1[i])) {
            결과 = 결과 + [집합1[i]]
        }
    }

    반환 결과
}

# 두 Set의 차집합 (A - B)
Set_차집합 = 함수(집합1, 집합2) {
    결과 = []

    i가 0부터 길이(집합1) 미만 {
        만약 (Set_포함(집합2, 집합1[i]) == 거짓) {
            결과 = 결과 + [집합1[i]]
        }
    }

    반환 결과
}

# 두 Set의 대칭 차집합 (A △ B = (A-B) ∪ (B-A))
Set_대칭_차집합 = 함수(집합1, 집합2) {
    차1 = Set_차집합(집합1, 집합2)
    차2 = Set_차집합(집합2, 집합1)
    반환 Set_합집합(차1, 차2)
}

# 집합1이 집합2의 부분집합인지 확인
Set_부분집합인가 = 함수(집합1, 집합2) {
    i가 0부터 길이(집합1) 미만 {
        만약 (Set_포함(집합2, 집합1[i]) == 거짓) {
            반환 거짓
        }
    }

    반환 참
}

# 두 Set이 같은지 확인
Set_같은가 = 함수(집합1, 집합2) {
    만약 (길이(집합1) != 길이(집합2)) {
        반환 거짓
    }

    반환 Set_부분집합인가(집합1, 집합2)
}

# 배열로부터 Set 생성
Set_배열로부터 = 함수(배열) {
    결과 = []

    i가 0부터 길이(배열) 미만 {
        결과 = Set_추가(결과, 배열[i])
    }

    반환 결과
}

# Set을 배열로 변환
Set_배열로 = 함수(집합) {
    반환 집합
}

# ============================================================================
# Map (맵/딕셔너리) - 키-값 쌍
# 내부 표현: [[키, 값], [키, 값], ...]
# ============================================================================

# 빈 Map을 생성한다
Map_생성 = 함수() {
    반환 []
}

# Map에 키-값 쌍을 추가/업데이트한다
Map_추가 = 함수(맵, 키, 값) {
    # 기존 키가 있으면 값 업데이트
    i가 0부터 길이(맵) 미만 {
        만약 (맵[i][0] == 키) {
            새맵 = []
            j가 0부터 길이(맵) 미만 {
                만약 (j == i) {
                    새맵 = 새맵 + [[키, 값]]
                } 아니면 {
                    새맵 = 새맵 + [맵[j]]
                }
            }
            반환 새맵
        }
    }

    # 새 키 추가
    반환 맵 + [[키, 값]]
}

# Map에서 키에 해당하는 값을 가져온다
Map_가져오기 = 함수(맵, 키) {
    i가 0부터 길이(맵) 미만 {
        만약 (맵[i][0] == 키) {
            반환 맵[i][1]
        }
    }

    반환 ""  # 키가 없으면 빈 문자열
}

# Map에서 키-값 쌍을 제거한다
Map_제거 = 함수(맵, 키) {
    결과 = []

    i가 0부터 길이(맵) 미만 {
        만약 (맵[i][0] != 키) {
            결과 = 결과 + [맵[i]]
        }
    }

    반환 결과
}

# Map에 키가 존재하는지 확인
Map_포함 = 함수(맵, 키) {
    i가 0부터 길이(맵) 미만 {
        만약 (맵[i][0] == 키) {
            반환 참
        }
    }

    반환 거짓
}

# Map의 크기를 반환
Map_크기 = 함수(맵) {
    반환 길이(맵)
}

# Map이 비어있는지 확인
Map_비어있는가 = 함수(맵) {
    반환 길이(맵) == 0
}

# Map의 모든 키를 배열로 반환
Map_키들 = 함수(맵) {
    결과 = []

    i가 0부터 길이(맵) 미만 {
        결과 = 결과 + [맵[i][0]]
    }

    반환 결과
}

# Map의 모든 값을 배열로 반환
Map_값들 = 함수(맵) {
    결과 = []

    i가 0부터 길이(맵) 미만 {
        결과 = 결과 + [맵[i][1]]
    }

    반환 결과
}

# Map의 모든 항목을 [[키, 값], ...] 배열로 반환
Map_항목들 = 함수(맵) {
    반환 맵
}

# Map을 병합 (맵2의 값이 우선)
Map_병합 = 함수(맵1, 맵2) {
    결과 = 맵1

    i가 0부터 길이(맵2) 미만 {
        결과 = Map_추가(결과, 맵2[i][0], 맵2[i][1])
    }

    반환 결과
}

# ============================================================================
# Queue (큐) - FIFO (First In First Out)
# ============================================================================

# 빈 Queue를 생성한다
Queue_생성 = 함수() {
    반환 []
}

# Queue의 뒤에 요소를 추가한다 (enqueue)
Queue_추가 = 함수(큐, 값) {
    반환 큐 + [값]
}

# Queue의 앞에서 요소를 제거하고 반환한다 (dequeue)
Queue_제거 = 함수(큐) {
    만약 (길이(큐) == 0) {
        반환 [큐, ""]
    }

    첫값 = 큐[0]
    새큐 = []

    i가 1부터 길이(큐) 미만 {
        새큐 = 새큐 + [큐[i]]
    }

    반환 [새큐, 첫값]
}

# Queue의 앞 요소를 확인만 한다 (제거하지 않음)
Queue_처음 = 함수(큐) {
    만약 (길이(큐) == 0) {
        반환 ""
    }

    반환 큐[0]
}

# Queue가 비어있는지 확인
Queue_비어있는가 = 함수(큐) {
    반환 길이(큐) == 0
}

# Queue의 크기를 반환
Queue_크기 = 함수(큐) {
    반환 길이(큐)
}

# Queue를 비운다
Queue_비우기 = 함수(큐) {
    반환 []
}

# ============================================================================
# Stack (스택) - LIFO (Last In First Out)
# ============================================================================

# 빈 Stack을 생성한다
Stack_생성 = 함수() {
    반환 []
}

# Stack의 위에 요소를 추가한다 (push)
Stack_추가 = 함수(스택, 값) {
    반환 스택 + [값]
}

# Stack의 위에서 요소를 제거하고 반환한다 (pop)
Stack_제거 = 함수(스택) {
    만약 (길이(스택) == 0) {
        반환 [스택, ""]
    }

    마지막_인덱스 = 길이(스택) - 1
    마지막값 = 스택[마지막_인덱스]
    새스택 = []

    i가 0부터 마지막_인덱스 미만 {
        새스택 = 새스택 + [스택[i]]
    }

    반환 [새스택, 마지막값]
}

# Stack의 최상단 요소를 확인만 한다 (제거하지 않음)
Stack_최상단 = 함수(스택) {
    만약 (길이(스택) == 0) {
        반환 ""
    }

    반환 스택[길이(스택) - 1]
}

# Stack이 비어있는지 확인
Stack_비어있는가 = 함수(스택) {
    반환 길이(스택) == 0
}

# Stack의 크기를 반환
Stack_크기 = 함수(스택) {
    반환 길이(스택)
}

# Stack을 비운다
Stack_비우기 = 함수(스택) {
    반환 []
}

# ============================================================================
# Deque (덱) - Double Ended Queue (양방향 큐)
# ============================================================================

# 빈 Deque를 생성한다
Deque_생성 = 함수() {
    반환 []
}

# Deque의 앞에 요소를 추가한다
Deque_앞에_추가 = 함수(덱, 값) {
    반환 [값] + 덱
}

# Deque의 뒤에 요소를 추가한다
Deque_뒤에_추가 = 함수(덱, 값) {
    반환 덱 + [값]
}

# Deque의 앞에서 요소를 제거하고 반환한다
Deque_앞에서_제거 = 함수(덱) {
    만약 (길이(덱) == 0) {
        반환 [덱, ""]
    }

    첫값 = 덱[0]
    새덱 = []

    i가 1부터 길이(덱) 미만 {
        새덱 = 새덱 + [덱[i]]
    }

    반환 [새덱, 첫값]
}

# Deque의 뒤에서 요소를 제거하고 반환한다
Deque_뒤에서_제거 = 함수(덱) {
    만약 (길이(덱) == 0) {
        반환 [덱, ""]
    }

    마지막_인덱스 = 길이(덱) - 1
    마지막값 = 덱[마지막_인덱스]
    새덱 = []

    i가 0부터 마지막_인덱스 미만 {
        새덱 = 새덱 + [덱[i]]
    }

    반환 [새덱, 마지막값]
}

# Deque의 앞 요소를 확인만 한다
Deque_처음 = 함수(덱) {
    만약 (길이(덱) == 0) {
        반환 ""
    }

    반환 덱[0]
}

# Deque의 뒤 요소를 확인만 한다
Deque_마지막 = 함수(덱) {
    만약 (길이(덱) == 0) {
        반환 ""
    }

    반환 덱[길이(덱) - 1]
}

# Deque가 비어있는지 확인
Deque_비어있는가 = 함수(덱) {
    반환 길이(덱) == 0
}

# Deque의 크기를 반환
Deque_크기 = 함수(덱) {
    반환 길이(덱)
}

# Deque를 비운다
Deque_비우기 = 함수(덱) {
    반환 []
}
