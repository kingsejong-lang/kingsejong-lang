# json 모듈
# KingSejong 표준 라이브러리 - JSON 처리

# ============================================================================
# 내장 JSON 함수
# ============================================================================
# 다음 함수들은 C++로 구현된 builtin 함수이며 직접 사용 가능합니다:
#
# JSON_파싱(json_문자열)                    - JSON 문자열을 파싱하여 값으로 변환
# JSON_문자열화(값, [들여쓰기])             - 값을 JSON 문자열로 변환
# JSON_파일_읽기(경로)                      - JSON 파일을 읽어서 파싱
# JSON_파일_쓰기(경로, 값, [들여쓰기])      - 값을 JSON 파일로 저장

# ============================================================================
# JSON Object 표현 방식
# ============================================================================
# KingSejong에서 JSON object는 [["key", value], ...] 형태의 2D 배열로 표현됩니다.
#
# 예시:
#   JSON: {"name": "Alice", "age": 30}
#   KingSejong: [["name", "Alice"], ["age", 30]]
#
# 이 방식을 사용하면 배열 함수들을 그대로 활용할 수 있습니다.

# ============================================================================
# 고수준 편의 함수
# ============================================================================

# JSON object에서 특정 키의 값을 가져온다
JSON_가져오기 = 함수(obj, 키) {
    만약 (!타입(obj) == "배열") {
        반환 없음
    }

    i가 0부터 길이(obj) 미만 {
        쌍 = obj[i]
        만약 (타입(쌍) == "배열" && 길이(쌍) == 2) {
            만약 (쌍[0] == 키) {
                반환 쌍[1]
            }
        }
    }

    반환 없음
}

# JSON object에 키-값 쌍을 추가한다 (새 object 반환)
JSON_추가 = 함수(obj, 키, 값) {
    새_obj = []

    # 기존 쌍들 복사 (같은 키가 있으면 건너뜀)
    키_존재 = 거짓
    i가 0부터 길이(obj) 미만 {
        쌍 = obj[i]
        만약 (쌍[0] == 키) {
            새_obj = 추가(새_obj, [키, 값])
            키_존재 = 참
        } 아니면 {
            새_obj = 추가(새_obj, 쌍)
        }
    }

    # 새 키면 추가
    만약 (!키_존재) {
        새_obj = 추가(새_obj, [키, 값])
    }

    반환 새_obj
}

# JSON object에서 특정 키를 제거한다 (새 object 반환)
JSON_제거 = 함수(obj, 키) {
    새_obj = []

    i가 0부터 길이(obj) 미만 {
        쌍 = obj[i]
        만약 (쌍[0] != 키) {
            새_obj = 추가(새_obj, 쌍)
        }
    }

    반환 새_obj
}

# JSON object의 모든 키를 배열로 반환한다
JSON_키목록 = 함수(obj) {
    키들 = []

    i가 0부터 길이(obj) 미만 {
        쌍 = obj[i]
        만약 (타입(쌍) == "배열" && 길이(쌍) == 2) {
            키들 = 추가(키들, 쌍[0])
        }
    }

    반환 키들
}

# JSON object의 모든 값을 배열로 반환한다
JSON_값목록 = 함수(obj) {
    값들 = []

    i가 0부터 길이(obj) 미만 {
        쌍 = obj[i]
        만약 (타입(쌍) == "배열" && 길이(쌍) == 2) {
            값들 = 추가(값들, 쌍[1])
        }
    }

    반환 값들
}

# JSON object에 특정 키가 존재하는지 확인한다
JSON_키존재 = 함수(obj, 키) {
    i가 0부터 길이(obj) 미만 {
        쌍 = obj[i]
        만약 (타입(쌍) == "배열" && 길이(쌍) >= 1) {
            만약 (쌍[0] == 키) {
                반환 참
            }
        }
    }

    반환 거짓
}

# 두 JSON object를 병합한다 (두 번째 object의 값이 우선)
JSON_병합 = 함수(obj1, obj2) {
    결과 = []

    # obj1의 모든 쌍 추가
    i가 0부터 길이(obj1) 미만 {
        결과 = 추가(결과, obj1[i])
    }

    # obj2의 쌍들로 업데이트/추가
    i가 0부터 길이(obj2) 미만 {
        쌍 = obj2[i]
        키 = 쌍[0]
        값 = 쌍[1]
        결과 = JSON_추가(결과, 키, 값)
    }

    반환 결과
}

# 빈 JSON object를 생성한다
JSON_빈객체 = 함수() {
    반환 []
}

# 배열을 JSON object로 변환한다 ([key, value] 쌍들의 배열로)
배열을_JSON객체로 = 함수(키배열, 값배열) {
    만약 (길이(키배열) != 길이(값배열)) {
        반환 []
    }

    결과 = []
    i가 0부터 길이(키배열) 미만 {
        결과 = 추가(결과, [키배열[i], 값배열[i]])
    }

    반환 결과
}

# JSON을 예쁘게 출력한다
JSON_예쁘게출력 = 함수(값) {
    json_str = JSON_문자열화(값, 2)
    출력(json_str)
}

# JSON 파일을 안전하게 읽는다 (파일이 없으면 빈 배열 반환)
JSON_안전하게읽기 = 함수(경로) {
    만약 (!파일_존재(경로)) {
        반환 []
    }

    반환 JSON_파일_읽기(경로)
}

# JSON 배열에서 조건을 만족하는 첫 번째 object를 찾는다
JSON_찾기 = 함수(배열, 키, 값) {
    i가 0부터 길이(배열) 미만 {
        항목 = 배열[i]
        만약 (타입(항목) == "배열") {
            항목_값 = JSON_가져오기(항목, 키)
            만약 (항목_값 == 값) {
                반환 항목
            }
        }
    }

    반환 없음
}

# JSON 배열에서 조건을 만족하는 모든 object를 필터링한다
JSON_필터링 = 함수(배열, 키, 값) {
    결과 = []

    i가 0부터 길이(배열) 미만 {
        항목 = 배열[i]
        만약 (타입(항목) == "배열") {
            항목_값 = JSON_가져오기(항목, 키)
            만약 (항목_값 == 값) {
                결과 = 추가(결과, 항목)
            }
        }
    }

    반환 결과
}
